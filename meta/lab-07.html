
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab 07</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="Обработка-и-печать-числовой-матрицы">7 - Обработка и печать числовой матрицы</h1>
<blockquote>
<p>Лабораторная работа 7 для студентов курса “Основы программирования” 1 курса кафедры ИУ5 МГТУ им Н.Э. Баумана.</p>
</blockquote>
<h2 id="содержание">Содержание</h2>
<ul>
<li><a href="#цель-работs">Цель работы</a></li>
<li><a href="#начало-работs">Начало работы</a></li>
<li><a href="#заданиe">Задание</a></li>
<li><a href="#указания-по-выполнению-работs">Указания по выполнению работы</a></li>
<ul>
    <li><a href="#создание-двухмерных-динамических-массивоb">Создание двухмерных динамических массивов.</a></li>
    <li><a href="#передача-многомерного-массива-в-функцию-с-помощью-параметроb">Передача многомерного массива в функцию с помощью параметров.</a></li>
<!--    <li><a href="#Программа-сортировки-строк-матрицы">Программа сортировки строк матрицы</a></li>-->
</ul>
</ul>
<h2 id="цель-работs">Цель работы</h2>
<p>На примере разработки функции печати числовой матрицы освоить следующие приемы программирования:</p>
<ul>
    <li>создание двухмерных динамических массивов;</li>
    <li>обработка матриц;</li>
    <li>использование файлов для хранения матриц;</li>
    <li>передача двухмерных массивов в функцию через параметры;</li>
    <li>форматированный вывод матриц на экран;</li>
    <li>доступ к элементам матрицы через указатели и с помощью индексов;</li>
    <li>освоение технологии структурного программирования.</li>
</ul>
<h2 id="начало-работs">Начало работы</h2>
<p>Зайдите в свою локальную директорию с репозиторием для выполнения лабораторных работ. Заберите ветку с соответствующей лабораторной работой из общего репозитория (в лабораторной работе 0 был отмечен меткой upstream):</p>
<pre><code>git pull upstream
</code></pre>
<p><strong>или</strong></p>
<pre><code>git pull upstream lab_7
</code></pre>
<p>Переключитесь на ветку с текущей лабораторной работой:</p>
<pre><code>git checkout lab_7
</code></pre>
<p>Свяжите ветку локального репозитория с вашим удаленным репозиторием:</p>
<pre><code>git push --set-upstream origin lab_7
</code></pre>
<h2 id="заданиe">Задание</h2>
    <h3>Часть первая</h3>
    <ol>
        <li>Создать матрицу <strong>twoDimensionalDynamicMatrix</strong> размером <em>numberOfRows</em> * <em>numberOfColumns</em> и заполнить её значениями:
            <ul>
                <li>все элементы главной диагонали равны 1;</li>
                <li>элементы, лежащие выше главной диагонали, вычисляются по формуле: a<sub>i,j</sub> = x<sup>i</sup> / (j!)<sup>i</sup>;</li>
                <li>элементы, лежащие ниже главной диагонали, по формуле : a<sub>i,j</sub> = (-x)<sup>i</sup> / (j!)<sup>i</sup>;</li>
                <p>где</p>
	            <ul>
                    <li>i = 1, 2, …, numberOfRows;</li>
	                <li>j = 1, 2, …, numberOfColumns;</li>
	                <li>x = 1.</li>
                </ul>
            </ul>
        </li>
        <li>Распечатать матрицу в научном или фиксированном формате.</li>
    </ol>

    <h4>Требования к первой части</h4>
    <p>Для выполнения первой части необходимо создать указанные ниже функции и учесть для них определенные требования:</p>
    <ol>
        <li><strong>Функция выделения памяти</strong> для двухмерного динамического массива размером <em>numberOfRows</em> * <em>numberOfColumns</em>, где  <strong>numberOfRows</strong> - количество строк, <strong>numberOfColumns</strong> - количество столбцов.</li>
        <li><strong>Функция заполнения матрицы</strong> <em>twoDimensionalDynamicMatrix</em>.
            <ul>Для вычисления значений элементов матрицы, необходимо использовать <a href="https://code.visualstudio.com/">рекуррентные</a> соотношения.</ul>
        </li>
        <li><strong>Функция вывода</strong>  двухмерного динамического массива размером <em>numberOfRows</em> * <em>numberOfColumns</em> в качестве аргументов должна принимать
            <ul>
                <li>точность вывода a<sub>i,j</sub>(precision),</li>
                <li>признак того, в каком формате распечатывать значения элементов матрицы: в экспоненциальном формате (<strong> 1.230000E-04 </strong>) или в формате с фиксированной точкой (<strong> 0.000123 </strong>);</li>
                <li>функция должна быть реализована в самостоятельном модуле.</li>
                <li>отображение строки массива не должно превышать рекомендуемую длину строки, описанную в руководстве Google по стилю C++, а именно не более <strong>80</strong> символов. Если строка выходит за пределы, то необходимо обеспечить перенос не помещающихся столбцов ниже.</li>
                <li>матрица или другие двухмерные массивы должны передаваться в функцию вывода через параметры.</li>
            </ul>
        </li>
        <li><strong>Функция освобождения памяти</strong>, выделенной для двухмерного динамического массива размером <em>numberOfRows</em> * <em>numberOfColumns</em></li>
    </ol>

    <h3>Часть вторая</h3>
    <ul>
        <li>Распечатать с помощью разработанной функции, используя вспомогательный массив указателей на строки, матрицу размером <code>staticMatrix[10][10]</code>,  заданную с помощью оператора описания (нединамическую). Значение элементов матрицы <code>staticMatrix</code> определяется соотношением: <code>a<sub>ij</sub> = i*10 + j</code>. </li>
        <li>Объясните, как передаются матрицы <code>twoDimensionalDynamicMatrix</code> и <code>staticMatrix</code> в функцию вывода матриц на экран.</li>
        <li>Вставьте в программу и объясните результаты выполнения следующих операторов для матрицы <code>staticMatrix[10][10]</code>:</li>
    </ul>

    <pre><code>std::cout &lt;&lt; staticMatrix &lt;&lt; "  " &lt;&lt; staticMatrix[0] &lt;&lt; "  " &lt;&lt; staticMatrix[2] &lt;&lt; std::endl;
std::cout &lt;&lt; staticMatrix[0][0] &lt;&lt; "  " &lt;&lt; **staticMatrix &lt;&lt; "  " &lt;&lt; *staticMatrix[0] &lt;&lt; std::endl;
std::cout &lt;&lt; *(*(staticMatrix+1)) &lt;&lt; "  " &lt;&lt; *B[1] &lt;&lt; std::endl;
std::cout &lt;&lt; *(staticMatrix[0]+1) &lt;&lt; "  " &lt;&lt; *(*staticMatrix+1) &lt;&lt; std::endl;
std::cout &lt;&lt; staticMatrix[0][20] &lt;&lt; " " &lt;&lt; *(staticMatrix[0]+20) &lt;&lt; "  " &lt;&lt;*staticMatrix[2] &lt;&lt; std::endl;</code></pre>

<h2 id="указания-по-выполнению-работs">Указания по выполнению работы</h2>
<!--    <p>Прежде чем приступать к выполнению задания прочитайте приведенный ниже текст, разберите и выполните пример программы сортировки строк матрицы.</p>-->
    <h3 id="создание-двухмерных-динамических-массивоb">Создание двухмерных динамических массивов</h3>
    <p>В динамической области памяти можно создавать двухмерные массивы с помощью операции new или функции mаllос. Остановимся на первом варианте, поскольку он более безопасен и прост в использовании.</p>
    <p>Обращение к элементам динамических массивов производится точно так же, как к элементам «обычных», с помощью конструкции вида a[i][j].</p>
    <p>Универсальный способ выделения памяти под двухмерный массив, когда обе его размерности задаются на этапе выполнения программы, приведен ниже:</p>
    <pre><code>int nrow, ncol;
std::cout << "Введите количество строк и столбцов :";
std::cin >> nrow >> ncol;
int **a = new int *[nrow];
for(int i = 0; i < nrow; ++i){
    a[i] = new int [ncol];
}</code></pre>
    <p>Для того чтобы понять, отчего динамические массивы описываются именно так, нужно разобраться в механизме индексации элемента массива. Поскольку для доступа к элементу массива применяется две операции разадресации, то переменная, в которой хранится адрес начала массива, должна быть указателем на указатель.</p>
    <p>В операторе 1 объявляется переменная типа "указатель на указатель на int" и выделяется память под массив указателей на строки массива (количество строк — nrow).</p>
    <p>В операторе 2 организуется цикл для выделения памяти под каждую строку массива.</p>
    <p>В операторе 3 каждому элементу массива указателей на строки присваивается адрес начала участка памяти, выделенного под строку двумерного массива.</p>
    <p>Каждая строка состоит из <em>ncol</em> элементов типа <strong>int</strong> (рис. 1).</p>
    <figure>
        <img src="img/l7_array.jpeg" alt="Рис. 1. Схема динамической области памяти, выделяемой под массивы">
        <figcaption>Рис. 1. Схема динамической области памяти, выделяемой под массивы</figcaption>
    </figure>

    <p>Освобождение памяти выделенной для массива с любым количеством измерений требуется освобождать каждый уровень вложенности отдельно с помощью операции delete [].</p>

    <h3 id="передача-многомерного-массива-в-функцию-с-помощью-параметроb">Передача многомерного массива в функцию с помощью параметров.</h3>
    <p>При необходимости передать в функцию многомерный массив с помощью параметра возникают неудобства, связанные с отсутствием в С++ и Си объектов типа многомерный массив. Если мы описываем массив с несколькими индексами, например:</p>
    <pre><code>double arr[6][4][2];</code></pre>
    <p>то это не трехмерный массив, а одномерный массив с именем arr, состоящий из <strong>6</strong> элементов, каждый из которых имеет тип <strong>double [4][2]</strong>. В свою очередь, каждый из этих элементов есть одномерный массив из четырех элементов типа <strong>double [2]</strong> . И, наконец, каждый из этих элементов является  массивом из двух элементов типа <strong>double</strong>.</p>
    <p>Очевидное и неверное решение при попытке передать в функцию матрицу – определить её заголовок следующим образом:</p>
    <pre><code>void func(double x[][], int n);</code></pre>
    <p>Здесь <strong>n</strong> – предполагаемый порядок квадратной матрицы; <strong>double x[][]</strong>  – попытка определить двухмерный массив с заранее неизвестными параметрами. На такую попытку транслятор ответит сообщением об ошибке:</p>
    <pre><code>Error…: Size of type is unknown or zero.</code></pre>
    <p>Вспомним – массив всегда одномерный, а его элементы должны иметь известную и фиксированную длину. В массиве <strong>double x[][]</strong> не только неизвестно количество элементов одномерного массива (это допустимо и их можно передать параметром <strong>int n</strong>), но ничего не известно о размерах этих элементов. Допустимое с точки зрения синтаксиса языка С++ решение:</p>
    <code>void func(double x[][4], int n);</code>
    <p>Нежизненность такого решения – необходимость фиксации второй размерности матрицы.</p>
    <p>Указанные ограничения на возможность применения многомерных массивов в качестве параметров функции можно обойти двумя путями.</p>
    <ul>
        <li>Первый путь – подмена многомерного массива, например, <strong>double x[3][4]</strong> одномерным <strong>double x[12]</strong> и имитация внутри функции доступа к нему как к многомерному массиву.</li>
        <li>Второй путь – использование вспомогательных одномерных массивов указателей на массивы.</li>
    </ul>
    <p>Такой массив указателей на строки матрицы используется при создании динамических массивов.</p>
    <p>Помните, что если размерность массива явно не указана, то в функцию с помощью параметров можно передавать только одномерные массивы.</p>
 <!--   <h4 id="Программа-сортировки-строк-матрицы">Программа сортировки строк матрицы</h4>

<p><i>Написать программу, которая упорядочивает строки прямоугольной целочисленной матрицы по возрастанию сумм их элементов.</i></p>
<p>Давайте на этом примере формализуем общий порядок создания структурной программы, которому мы ранее следовали интуитивно. Этого порядка полезно придерживаться при решении даже простейших задач.</p>
<p><strong><i>I. Исходные данные, результаты и промежуточные величины.</i></strong> Как уже неоднократно упоминалось, начинать решение задачи необходимо с четкого описания того, что является ее исходными данными и результатами и каким образом они будут представлены в программе.</p>
<p><i>Исходные данные:</i> Поскольку размерность матрицы неизвестна, придется использовать динамический массив элементов целого типа. Ограничимся типом <code>int</code>, хотя для общности следовало бы воспользоваться максимально длинным целым типом.</p>
<p><i>Результаты:</i> Результатом является та же матрица, но упорядоченная. Это значит, что нам не следует заводить для результата новую область памяти, а необходимо упорядочить матрицу на том же месте. В данной задаче такое требование может показаться излишним, но в общем случае, когда программист работает в команде и должен передавать результаты коллеге, это важно. Представьте себе ситуацию, когда коллега думает, что получил от вас упорядоченную матрицу, а на самом деле вы сформировали ее в совершенно другой области памяти.</p>
<p><i>Промежуточные величины:</i> Кроме конечных результатов, в любой программе есть промежуточные, а также служебные переменные. Следует выбрать их тип и способ хранения.</p>
<p>Очевидно, что если требуется упорядочить матрицу по возрастанию сумм элементов ее строк, эти суммы надо вычислить и где-то хранить. Поскольку все они потребуются при упорядочивании, их надо записать в массив, количество элементов которого соответствует количеству строк матрицы, а i-й элемент содержит сумму элементов i-й строки. Количество строк заранее неизвестно, поэтому этот массив также должен быть динамическим. Сумма элементов строки может превысить диапазон значений, допустимых для отдельного элемента строки, поэтому для элемента этого массива надо выбрать тип <code>long</code>.</p>
<p>После того как выбраны структуры для хранения данных, можно подумать и об алгоритме (именно в таком порядке, а не наоборот — ведь алгоритм зависит от того, каким образом представлены данные).</p>
<p><strong><i>II. Алгоритм работы программы.</i></strong> Для сортировки строк воспользуемся одним из самых простых методов — методом выбора. Он состоит в том, что из массива выбирается наименьший элемент и меняется местами с первым элементом, затем рассматриваются элементы, начиная со второго, и наименьший из них меняется местами со вторым элементом и так далее <em>n - 1</em> раз. Одновременно с обменом элементов массива выполняется и обмен значений двух соответствующих строк матрицы.</p>
<p>Алгоритм сначала записывается в самом общем виде (например, так, как это сделано выше). Пренебрегать словесным описанием не следует, потому что процесс формулирования на естественном языке полезен для более четкого понимания задачи. При этом надо стремиться разбить алгоритм на простую последовательность шагов. Например, любой алгоритм можно первоначально разбить на этапы:</p>
<ul>
<li>ввода исходных данных,</li>
<li>вычислений,</li>
<li>и вывода результата.</li>
</ul>
<p>Вычисление в данном случае состоит из двух шагов: формирование сумм элементов каждой строки и упорядочивание матрицы. Упорядочивание состоит в выборе наименьшего элемента и обмене с первым из рассматриваемых. Разветвленные алгоритмы и алгоритмы с циклами полезно представить в виде обобщенной блок-схемы.</p>
<p><strong><i>III. Кодирование</i></strong> Когда алгоритм полностью прояснился, можно переходить к написанию программы. Одновременно с этим продумываются и подготавливаются тестовые примеры. Не ленитесь придумать переменным понятные имена и сразу же при написании аккуратно форматировать текст программы, чтобы по положению оператора было видно, на каком уровне вложенности он находится.</p>
<p><strong><i>IV. Отладка</i></strong> При написании программы рекомендуется всегда включать в нее промежуточную печать вычисляемых величин в удобном для восприятия формате. Это простой и надежный способ контроля хода выполнения программы.</p>
<p>Не нужно стремиться написать сразу всю программу. Сначала пишется и отлаживается фрагмент, содержащий ввод исходных данных. Затем промежуточную печать можно убрать и переходить к следующему функционально законченному фрагменту алгоритма.</p>
<p>Для отладки полезно выполнять программу по шагам с наблюдением значений изменяемых величин и сравнением их с контрольным примером.</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iomanip&gt;

int main(){
    std::ifstream fin("input.txt");
    if (!fin){
        std::cout &lt;&lt; "Файл input.txt не найден" &lt;&lt; std::endl;
        return 1;
    }
    int nrow, ncol;
    fin &gt;&gt; nrow &gt;&gt; ncol;
    int **a = new int *[nrow];
    for (int i = 0; i &lt; nrow; ++i) a[i] = new int[ncol];

    for (int i = 0; i &lt; nrow; ++i)
        for (int j = 0; j &lt; ncol; ++j)
            fin &gt;&gt; a[i][j];

    long *sum = new long[nrow];
    for (int i = 0; i &lt; nrow; ++i){
        sum[i] = 0;
        for (int j = 0; j &lt; ncol; ++j)
            sum[i] += a[i][j];
    }

    long buf_sum;
    int nmin, buf_a;
    for (int i = 0; i &lt; nrow - 1; ++i){
        nmin = i;
        for (int j = i + 1; j &lt; nrow; ++j)
            if (sum[j] &lt; sum[nmin]) nmin = j;
        std::swap(sum[i], sum[nmin]);
        for (int j = 0; j &lt; ncol; ++j)
            std::swap(a[i][j], a[nmin][j]);
    }

    for (int i = 0; i &lt; nrow; ++i){
        for (int j = 0; j &lt; ncol; ++j)
            std::cout &lt;&lt; std::setw(4) &lt;&lt; a[i][j] &lt;&lt; " ";
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
<p>В программе используются две буферные переменные: <code>buf_sum</code>, через которую осуществляется обмен двух значений сумм, имеет такой же тип, что и сумма, а для обмена значений элементов массива определена переменная <code>buf_a</code> того же типа, что и элементы массива.</p>
<p>Как и в предыдущем примере, данные читаются из файла. Этот способ ввода является предпочтительнее стандартного ввода, поскольку при формировании файла легче продумать, какие значения лучше взять для исчерпывающего тестирования программы. В данном случае для первого теста следует подготовить массив не менее чем из четырех строк с небольшими значениями элементов для того, чтобы можно было в уме проверить, правильно ли вычисляются суммы.</p>
<p>Ввод размерности массива и его элементов выполняется из файла <strong>input.txt</strong>, расположенного в том же каталоге, что и программа, а результаты выводятся в файл <strong>output.txt</strong>. В программе определены объект <code>fin</code> класса входных файловых потоков и объект <code>fout</code> класса выходных файловых потоков. Файловые потоки описаны в заголовочном файле <code>&lt;fstream.h&gt;</code>. Работа с этими объектами аналогична работе со стандартными объектами <code>cin</code> и <code>cout</code>, то есть можно пользоваться теми же операциями помещения в поток <code>&lt;&lt;</code> и извлечения из потока <code>&gt;&gt;</code>.</p>
<p>Предполагается, что файл с именем <code>input.txt</code> находится в том же каталоге, что и текст программы, иначе следует указать полный путь, дублируя символ обратной косой черты, так как иначе он будет иметь специальное значение: <pre><code>ifstream fin("c:\\A_Worker\\input.txt", ios::in | ios::nocreate);</code></pre>
<p>Обратите внимание, что для контроля вместе с исходным массивом рядом с каждой строкой выводится сумма ее элементов, отделенная вертикальной чертой.</p>
<p>Дополнительно следует проверить, правильно ли упорядочивается массив из одной и двух строк и столбцов, поскольку многие ошибки при написании циклов связаны с неверным указанием их граничных значений.</p>-->
<p>Основные правила работы с двумерными массивами</p>
<ul>
    <li>В массивах, определенных с помощью операторов описания, обе размерности должны быть константами или константными выражениями.</li>
    <li>Массив хранится по строкам, все строки хранится в непрерывной области памяти.</li>
    <li>Первый индекс всегда представляет собой номер строки, второй — номер столбца. Каждый индекс может изменяться от 0 до значения соответствующей размерности, уменьшенной на единицу.</li>
    <li>При описании массива можно в фигурных скобках задать начальные значения его элементов.</li>
    <li>Для выделения динамической памяти под массив, в котором все размерности переменные, используются циклы.</li>
    <li>Освобождение памяти выделенной под массив с любым количеством измерений требуется освобождать каждый уровень вложенности отдельно с помощью операции delete [].(<code>delete[] array[i]</code>, где <code>array[i]</code> – имя i-го массива.)</li>
</ul>

</body>
</html>
