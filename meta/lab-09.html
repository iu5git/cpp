
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab 09</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
<style>
.fake-link {
  color: #49a8db;    /* цвет как у обычной ссылки */
  text-decoration: none;  /* убираем подчёркивание */
  cursor: pointer;   /* курсор как у ссылки */
}
</style>
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="Вычисление-обратной-матрицы-методом-Гаусса-Жордана.">9 - Вычисление обратной матрицы методом Гаусса-Жордана.</h1>
<blockquote>
<p>Лабораторная работа 9 для студентов курса “Основы программирования” 1 курса кафедры ИУ5 МГТУ им Н.Э. Баумана.</p>
</blockquote>
<h2 id="содержание">Содержание</h2>
<ul>
  <li><a href="#цель-работs">Цель работы</a></li>
  <li><a href="#начало-работs">Начало работы</a></li>
  <li><a href="#заданиe">Задание</a></li>
  <li>
    <a href="#указания-по-выполнению-работs">Указания по выполнению работы</a>
    <ul>
      <li><a href="#" class="fake-link">Вычисление обратной матрицы методом Гаусса-Жордана.</a></li>
      <li>
        <a href="#алгоритм-вычисления-обратной-матрицs">Алгоритм вычисления обратной матрицы</a>
        <ul>
          <li><a href="#прямой-хоd">Прямой ход</a></li>
          <li><a href="#обратный-хоd">Обратный ход</a></li>
        </ul>
      </li>
      <li><a href="#точность-вычисления-обратной-матрицs">Точность вычисления обратной матрицы.</a></li>
    </ul>
  </li>
</ul>
<h2 id="цель-работs">Цель работы</h2>
<p></p>
<ul>
    <li>разработка программы, реализующей алгоритм вычисления обратной матрицы методом Гаусса-Жордана;</li>
    <li>использование разработанных функций для решения систем линейных уравнений.</li>
</ul>
<h2 id="начало-работs">Начало работы</h2>
<p>Зайдите в свою локальную директорию с репозиторием для выполнения лабораторных работ. Заберите ветку с соответствующей лабораторной работой из общего репозитория (в лабораторной работе 0 был отмечен меткой upstream):</p>
<pre><code>git pull upstream
</code></pre>
<p><strong>или</strong></p>
<pre><code>git pull upstream lab_9
</code></pre>
<p>Переключитесь на ветку с текущей лабораторной работой:</p>
<pre><code>git checkout lab_9
</code></pre>
<p>Свяжите ветку локального репозитория с вашим удаленным репозиторием:</p>
<pre><code>git push --set-upstream origin lab_9
</code></pre>
<h2 id="заданиe">Задание</h2>
<p>Создать функцию для вычисления обратной матрицы по методу Гаусса-Жордана. Размер матрицы передавать в функцию в качестве параметра. Для упрощения алгоритма следует присоединить единичную матрицу справа к исходной и выполнять все преобразования над объединенной матрицей размером N*2N. Обратная матрица получится на месте единичной в столбцах N…2N, а на месте исходной матрицы в столбцах 0…(N-1) должна получиться единичная матрица.</p>
<p>Включить в алгоритм проверку на существование обратной матрицы. Для этого в в прямом ходе перед делением выполнить проверку на ноль элементов главной диагонали исходной матрицы. Если элемент равен 0, то нужно поменять местами текущую строку с одной из нижележащих строк, в которой элемент в соответствующем столбце не равен 0.</p>
<p>Если таких строк нет, то выдать сообщение: «Обратная матрица не существует».</p>
<p>Применить функцию для решения системы линейных алгебраических уравнений.</p>
<h2 id="указания-по-выполнению-работs">Указания по выполнению работы</h2>
<h3>Вычисление обратной матрицы методом Гаусса-Жордана.</h3>
<p>В математике все доказательства, связанные с получением обратной матрицы, полностью основаны на применении определителей. Этот процесс ясно показывает способ вычисления каждого элемента обратной матрицы, но не эффективен при обращении матриц большого порядка, поскольку требует излишних вычислений.</p>
<p>На практике для получения обратной матрицы используются методы, основанные на решении системы линейных алгебраических уравнений.</p>
<p>В лабораторной работе рассматривается вычисление обратной матрицы методом Гаусса-Жордана. Гаусс предложил метод решения систем  линейных алгебраических уравнений путем последовательного исключения переменных, а затем Жордан использовал его для нахождения обратной матрицы, добавив преобразование единичной матрицы.</p>
<h3 id="алгоритм-вычисления-обратной-матрицs">Алгоритм вычисления обратной матрицы</h3>
<p>Прежде чем приступать к программированию, разработаем численный пример  получения обратной матрицы методом Гаусса-Жордана. Это позволит лучше понять алгоритм метода и использовать этот пример в качестве контрольного при разработке алгоритма программы. Предположим, имеется матрица</p>
<p>\( \mathbf{A} = \begin{bmatrix} 2 & 5 & 7 \\ 3 & 9 & 15 \\ 5 & 16 & 20 \end{bmatrix} \)</p>
<p>Метод Гаусса-Жордана предполагает нахождение обратной матрицы путем решения  следующей системы уравнений</p>
<p>\( \mathbf{A} \begin{bmatrix} x\\ y\\ z \end{bmatrix} = \begin{bmatrix} a\\ b\\ c \end{bmatrix} \quad \quad \quad \quad \quad \quad (1) \)</p>
<p>относительно <code><i>х, у</i></code> и <code><i>z</i></code> с помощью обычной процедуры последовательного исключения (здесь символы <code><i>х, у, z</i></code> и <code><i>а, b, с</i></code> характеризуют скалярные величины). Умножение обеих частей уравнения слева на <code><strong>A</strong><sup>-1</sup></code> дает решение в виде</p>
<p>\( \begin{bmatrix} x\\ y\\ z \end{bmatrix} = \mathbf{A^{-1}} \begin{bmatrix} a\\ b\\ c \end{bmatrix} \quad \quad \quad \quad \quad (2) \)</p>
<p>если <code><strong>A</strong><sup>-1</sup></code> существует.</p>
<p>Следовательно, если решение системы (1) относительно <code><i>х, у</i></code> и <code><i>z</i></code> выражено в явном виде через <code><i>a, b</i></code> и <code><i>c</i></code> и записано в матричной форме, то приводящая к решению матрица равна <code><strong>A</strong><sup>-1</sup></code>. Воспроизведем полностью этот процесс.</p>
<p>Допустим, что уравнения (1) имеют следующий вид:</p>
<pre><code>2х + 5у + 7z = a,	  (3)
3х + 9у + 15z = b,	  (4)
5х + 16y + 20z = c.	  (5)
</code></pre>
<p>Деление (3) на 2 дает:</p>
<pre><code><i>x + 2,5y + 3,5z = 0,5a.</i>	  (6)</code></pre>
<p>Умножим обе части уравнения (6) на три и вычтем их из (4), а затем, умножив обе части уравнения (6) на пять, вычтем их из (5). Тогда</p>
<pre><code><i>1,5y + 4,5z = b - 1,5a</i>	  (7)
</code></pre>
<p>и</p>
<pre><code><i>3,5y + 2,5z = c - 2,5a.	  (8)</i></code></pre>
<p>Разделив (7) на 1,5 и умножив (8) на 2, получим</p>
<pre><code><i>у + 3z = b/1,5 - a,	  (9)
7y + 5z = 2c - 5a.	 (10)</i></code></pre>
<p>Вычитая (9), умноженное на 7, из (10), мы получим</p>
<pre><code><i>-16z = 2c - 5a - 7 (b/1,5 - a).</i></code></pre>
<p>Следовательно,</p>
<pre><code><i>z = (2a - 7b/1,5 + 2c)/(- 16) = (-3a + 7b - 3c)/24.		           (11)</i></code></pre>
<p>Подстановка <code><i>z</i></code> в (9) приводит к следующему результату</p>
<pre><code><i>у = (—15a — 5b + 9c)/24,	 		(12)</i></code></pre>
<p>а подстановка <code><i>y</i></code> и <code><i>z</i></code> в (6) дает</p>
<pre><code><i>x = (60a — 12b — 12c)/24.			(13)</i></code></pre>
<p>Последние три результата могут быть представлены в матричном виде следующим образом:</p>
<p>\( \begin{bmatrix} x\\ y\\ z \end{bmatrix} = \displaystyle\frac{1}{24} \begin{bmatrix} 60 & -12 & -12 \\ -15 & -5 & 9 \\ -3 & 7 & -3 \end{bmatrix} \begin{bmatrix} a\\ b\\ c \end{bmatrix} \quad \quad \quad \quad \quad (14) \)</p>
<p>Сравнивая этот результат с (2), мы приходим к заключению, что</p>
<p>\( \mathbf{A^{-1}} = \displaystyle\frac{1}{24} \begin{bmatrix} 60 & -12 & -12 \\ -15 & -5 & 9 \\ -3 & 7 & -3 \end{bmatrix} \)</p>
<p>Умножив обе части этого соотношения на <code><strong>A</strong></code>, можно убедиться в справедливости полученного результата. Эта процедура, естествен­но, очень утомительна для человека, но для компьютера она не представляется сложной: отдельные шаги расчетов по существу одни и те же как для больших, так и для маленьких матриц (для больших их просто больше).</p>
<p>Так как компьютер работает с числами (а не с переменными <code><i>a, b, c</i></code>), то для того чтобы решение системы (1) относительно <code><i>x, у</i></code> и <code><i>z</i></code> выразить в <strong>явном виде</strong> через <code><i>a, b</i></code> и <code><i>c</i></code> и записать в матричной форме, умножим правую часть системы уравнений (1) на единичную матрицу и будем выполнять над ней те же преобразования, что и над исходной матрицей.</p>
<p>Алгоритм преобразования состоит из двух шагов:</p>
<ol>
  <li id="прямой-хоd">Прямой ход. В результате исходная матрица преобразуется в верхнюю треугольную матрицу.</li>
  <li id="обратный-хоd">Обратный ход. В результате исходная матрица преобразуется в единичную, а введенная единичная матрица – в матрицу, обратную исходной, то есть система уравнений (1) преобразуется в систему уравнений (2).</li>
</ol>
<p>Выполним с помощью этого алгоритма рассмотренный выше пример:</p>
<p>\(\begin{bmatrix} 2 & 5 & 7 \\ 3 & 9 & 15 \\ 5 & 16 & 20 \end{bmatrix} \begin{bmatrix} x\\ y\\ z \end{bmatrix} = \begin{bmatrix} 0 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} a\\ b\\ c \end{bmatrix} \)</p>
<h4><i>Шаг 1. Прямой ход.</i></h4>
<p>Исключаем <code><i>x</i></code> из нижележащих строк:</p>
<p>\(\begin{bmatrix} 1 & 2,5 & 3,5 \\ 0 & 1,5 & 4,5 \\ 0 & 3,5 & 2,5 \end{bmatrix} \quad \quad \quad \begin{bmatrix} 0,5 & 0 & 0 \\ -1,5 & 1 & 0 \\ -2,5 & 0 & 1 \end{bmatrix} \)</p>
<p>Исключаем  <code><i>y</i></code>:</p>
<p>\(\begin{bmatrix} 1 & 2,5 & 3,5 \\ 0 & 1 & 3 \\ 0 & 0 & -16 \end{bmatrix} \quad \quad \quad \begin{bmatrix} 0,5 & 0 & 0 \\ -1 & 2/3 & 0 \\ 2 & -14/3 & 2 \end{bmatrix} \)</p>
<p>Устанавливаем коэффициент при <code><i>z</i></code> равным 1:</p>
<p>\(\begin{bmatrix} 1 & 2,5 & 3,5 \\ 0 & 1 & 3 \\ 0 & 0 & 1 \end{bmatrix} \quad \quad \quad \begin{bmatrix} 0,5 & 0 & 0 \\ -1 & 2/3 & 0 \\ -1/8 & 7/24 & -1/8 \end{bmatrix} \)</p>
<h4><i>Шаг 2. Обратный ход.</i></h4>
<p>Исключаем <code><i>z</i></code> из всех вышележащих строк:</p>
<p>\(\begin{bmatrix} 1 & 2,5 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \quad \quad \quad \begin{bmatrix} 15/16 & -49/48 & 7/16 \\ -5/8 & -5/24 & 3/8 \\ -1/8 & 7/24 & -1/8 \end{bmatrix} \)</p>
<p>Исключаем  <code><i>y</i></code>:</p>
<p>\(\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \quad \quad \quad \begin{bmatrix} 5/2 & -1/2 & -1/2 \\ -5/8 & -5/24 & 3/8 \\ -1/8 & 7/24 & -1/8 \end{bmatrix} \)</p>
<p>Представим результат в матричном виде:</p>
<p>\(\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x\\ y\\ z \end{bmatrix} = \displaystyle\frac{1}{24} \begin{bmatrix} 60 & -12 & -12 \\ -15 & -5 & 9 \\ -3 & 7 & -3 \end{bmatrix} \begin{bmatrix} a\\ b\\ c \end{bmatrix} \)</p>
<p>Сравнив результат с (14), убеждаемся, что все вычисления сделаны правильно.</p>
<h3 id="точность-вычисления-обратной-матрицs">Точность вычисления обратной матрицы.</h3>
<p>Основной источник погрешностей при выполнении вычислений – это ошибки округления. Ошибки округления всегда возникают в последнем значащем разряде. Однако накопление ошибок в связи с выполнением большого количества вычислений может повлиять на последние два и более разрядов.</p>
<p>Влияние погрешностей округления на результат вычислений зависит от используемых методов расчета. Наиболее часто встречающиеся источники увеличения влияния погрешностей округления на результат – деление на малые величины и сложение больших величин с малыми величинами. Полностью предупредить подобные ошибки нельзя, однако в каждом конкретном случае нужно использовать методы расчета, которые сводят к минимуму влияние ошибок. Например, если нужно складывать большое количество малых величин с большой величиной, то нужно сложить сначала все малые величины, а затем их сумму, которая уже не будет такой малой, сложить с большой величиной. Если при сложении последовательно прибавлять малые величины к большой, то при выравнивании порядков малые величины будут превращаться в ноль и не повлияют на результат сложения. Общее правило заключается в том, что надо так организовать процесс вычислений, чтобы, по возможности, все  операции выполнялись бы над величинами одного порядка.</p>
<p>Вообще говоря, компьютер не делает ошибок, но он выполняет ошибочные программы точно так же, как и правильные. Поэтому оценку точности результатов вычислений должен делать программист. В случае получения обратной матрицы правильность результата вычислений можно оценить путем умножения обратной матрицы на исходную. В результате должна получиться единичная матрица.</p>
</body>
</html>
